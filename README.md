# cs480-24puzzle
CS480 – Module 3 Assignment
Uninformed Search (24-Puzzle)
Author: Donnel Garner
Date: 02/12/2026

My program implements a Breadth-First-Search and a Depth-First-Search of the 24 puzzle problem.

To run with output in the terminal:
	- Run python3 HW1FinalSolution.py
	- The program will direct you from there.
	
INITIAL SET: 2,11,0,4,5,6,1,3,9,12,8,19,13,7,10,18,17,14,15,20,16,21,22,23,24
SOLUTION SET: 1,2,3,4,5,6,7,8,9,10,11,12,14,18,15,16,17,13,19,20,21,22,23,0,24

WEBSITE: https://donnelgarner.com/projects/puzzle/ (I gave up on PHP, as it crashed my server)  
GOOGLE COLAB: https://colab.research.google.com/drive/1a1obwHk_dHjDOfSBylXnJm2iYJ0SCD-o?usp=sharing  
GITHUB: https://github.com/skyelogic/cs480-24puzzle/

# ------ #   INTRODUCTION   # ------ #

The puzzle is represented as a tuple of 25 integers (0–24), where 0 represents the blank tile.
Moves are generated by sliding the blank tile up, down, left, or right.

To evaluate performance, the program tracks:
	- Expanded nodes
	- Generated nodes
	- Maximum frontier size
	- Runtime
	- Peak Python memory usage (via tracemalloc)
	- Process memory usage (RSS, when available)

Safety limits (node limit and time limit) were added to prevent the program from running indefinitely or exhausting system memory.

# ------ #   STATE SPACE COMPLEXITY ISSUE   # ------ #

		The 24-puzzle has:
	25! / 2 ≈ 7.76 × 10^24
		reachable states.

This is an astronomically large number. Even if a computer explored 1 million states per second, it would take:  

    10^24 / 10^6 = 10^18 seconds ≈ 30 billion years  
    
to explore the entire state space.

This demonstrates why uninformed search is computationally infeasible for large sliding puzzles.

# ------ #   BREADTH-FIRST SEARCH (BFS)   # ------ #

Theoretical Properties:
- Complete: Yes
- Optimal: Yes (finds shortest path)

Why BFS Exhausts Memory:
BFS must store every generated state in memory to avoid revisiting states.

The total number of nodes up to depth d is:  
    1 + b + b^2 + ... + b^d = O(b^d)

Using a conservative estimate of b = 2.5:  
    2.5^20 ≈ 95,000,000 states

Even if each stored state required only 2 KB of memory:  
    95,000,000 × 2 KB = 190 GB

Typical machines do not have this amount of RAM.  
Therefore, BFS inevitably exhausts memory on sufficiently deep 24-puzzle instances.

Experimental Observations:  
- The frontier grows extremely rapidly.
- Memory usage increases quickly.
- The node limit or time limit is reached before a solution is found.
- Maximum frontier size becomes very large even at moderate depths.

These results confirm the theoretical exponential growth of BFS.


# ------ #   DEPTH-FIRST SEARCH (DFS)   # ------ #
Theoretical Properties:  
- Complete: No (without depth limit)
- Optimal: No

Why Plain DFS Can Appear to “Hang Forever”:
DFS explores one branch deeply before considering alternatives.

If the goal state is not found early, DFS may:  
- Explore extremely deep branches first
- Miss shallow solutions
- Traverse a vast portion of the state space

Given the enormous state space (~10^24), DFS can effectively run for years before reaching a solution.

While it does not loop infinitely (because repeated states on the current path are prevented), the sheer size of the search tree makes it practically non-terminating without a depth limit.

Experimental Observations:
- Memory usage remains much lower than BFS.
- Maximum frontier size is significantly smaller.
- The algorithm may fail to find a solution if the depth limit is too small.
- Increasing the depth limit increases runtime significantly.


# ------ #   COMPARISON OF BFS AND DFS   # ------ #

| Property   | BFS | DFS (Depth-Limited) |
|--------|-----|---------|
| Complete | Yes  | Only if limit sufficient     |
| Optimal   | Yes  | No     |
| Memory | Usage Extremely High  | Much Lower     |
| Runtime Growth   | Exponential  | Exponential     |
| Practical for 24-Puzzle | No  | Only with limits     |

Observed Behavior:
- BFS consumes memory very rapidly due to storing all visited states.
- DFS consumes much less memory but may explore deep irrelevant branches.
- Both algorithms are inefficient for large puzzles


# ------ #   CONCLUSION   # ------ #

This assignment demonstrates:
- The exponential growth of search trees.
- Why uninformed search is impractical for large combinatorial problems.
- The tradeoff between memory usage (BFS) and search order unpredictability (DFS).

BFS guarantees optimality but exhausts memory rapidly.  
DFS uses less memory but can effectively run indefinitely without depth limits.  

The 24-puzzle provides a clear example of why informed search strategies are necessary in Artificial Intelligence.


# ------ #   REFERENCES   # ------ #
https://github.com/Nageshbvrch/CS580_HW1  
https://canvas.odu.edu/  
https://colab.research.google.com/drive/1a1obwHk_dHjDOfSBylXnJm2iYJ0SCD-o?usp=sharing  
https://code.claude.com/docs/en/overview  
https://donnelgarner.com/projects/puzzle/
